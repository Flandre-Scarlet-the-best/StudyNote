#ТипыДанных #overflow #underflow #PromotionRules

При выполнение операции присваивания происходит **неявное** (автоматическое) преобразование типов, при условии, что оба типа являются *совместимыми*, а целевой тип обладает более широким диапазоном допустимых значений.
Порядок расширения задаётся цепочкой:
![[Pasted image 20240707150001.png]]
Пунктирными стрелками показаны автоматические преобразования с потерей точности.
```Java
int i = 10;
long m = i;
```

**Явное преобразование**:
```Java
int i = 98;
char ch;
ch = (char) i;
```
При явном преобразовании типов может возникнуть искажение информации. Такое искажение бывает двух типов:
- *overflow* (переполнение)
- *underflow* (потеря значений)
```Java
//Пример overflow: 
short maxValue = 256; 
byte bb = (byte) maxValue; 
//Результат будет 0
```
____
```Java
//Примеры underflow:
double d1 = 0.3333333333333333;
// потеря чисел после точки начиная с 8 знака
float f1 = (float) d1; 
//Результат: 0.33333334 

float f3 = 3.64f; 
int i3 = (int) f3; 
// дробная часть отбрасывается 
//Результат: 3
```

*Promotion rules*:
- Все  значения типов *char*, *short* и *byte* автоматически преобразуются в тип *int* .
- Если хотя бы один операнд в выражении имеет  тип _long_ , то все выражение будет повышено до  _типа long_ .
- Если хотя бы один операнд в выражении имеет  тип _float_ , то все выражение будет повышено до _типа float._
- Если хотя бы один операнд в выражении имеет  тип _double_ , то все выражение будет повышено до  _типа double_ .